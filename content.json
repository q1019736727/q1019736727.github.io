{"meta":{"title":"Ask_Js","subtitle":null,"description":"learn more","author":"Ask_Js","url":"http://q1019736727.github.io","root":"/"},"pages":[{"title":"文章分类","date":"2019-03-02T06:52:25.000Z","updated":"2019-04-08T14:10:16.000Z","comments":true,"path":"categories/index.html","permalink":"http://q1019736727.github.io/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2023-10-11T02:36:28.258Z","updated":"2023-10-11T02:36:28.258Z","comments":true,"path":"about/index.html","permalink":"http://q1019736727.github.io/about/index.html","excerpt":"","text":"农民工"},{"title":"Tags","date":"2023-10-11T02:02:08.586Z","updated":"2019-04-08T14:10:16.000Z","comments":true,"path":"tags/index.html","permalink":"http://q1019736727.github.io/tags/index.html","excerpt":"","text":""},{"title":"Project","date":"2023-10-11T02:02:08.586Z","updated":"2019-04-08T14:10:16.000Z","comments":true,"path":"project/index.html","permalink":"http://q1019736727.github.io/project/index.html","excerpt":"","text":""}],"posts":[{"title":"React.js之react-router","slug":"react-router","date":"2019-03-17T13:50:23.000Z","updated":"2019-04-08T14:10:16.000Z","comments":true,"path":"2019/03/17/react-router/","link":"","permalink":"http://q1019736727.github.io/2019/03/17/react-router/","excerpt":"前言&emsp;当我刚刚开始接触react的时候，路由的跳转到底该使用react-router还是使用react-router-dom,这个是让我们很懵逼的，下面就先来说说react-router和react-router-dom的关系以及区别","text":"前言&emsp;当我刚刚开始接触react的时候，路由的跳转到底该使用react-router还是使用react-router-dom,这个是让我们很懵逼的，下面就先来说说react-router和react-router-dom的关系以及区别 (一)api的区别 react-router提供了router的核心api，如Router、Route、Switch等等，但是并没有提供相关dom操作的api react-router-dom提供了通过dom触发的时间路由，例如BrowserRouter、Route、Link等 (二)功能的差异性 react-router-dom是基于react-router实现的，并且加入了一些浏览器运行的一些功能， 例如：Link组件会渲染一个a标签，BrowserRouter使用 HTML5 提供的 history API可以保证你的 UI 界面和 URL 保持同步，HashRouter使用 URL 的 hash 部分保证你的 UI 界面和 URL 保持同步 所以综上所说因素，一般我们只要引入react-router-dom即可,react-router-dom会自动引入依赖库react-router,在react-router@v4.0版本以后，React Router被拆分成三个包：react-router,react-router-dom和react-router-native，目前网站搭建只需要引入react-router-dom即可，更多用法可以查看官网123yarn add react-router-dom//或则npm install react-router-dom react-router-dom（一) BrowserRouter与HashRouter&emsp;HashRouter与BrowserRouter这两个路由是基本，我们需要将他们包裹在最外层，当然他们的内层也只能包裹一个元素，例如这样1234567891011121314151617import &#123;BrowserRouter as Router, HashRouter, Route&#125; from \"react-router-dom\"; &lt;HashRouter&gt; &lt;div&gt; &lt;Route exact path='/' component=&#123;Login&#125;&gt;&lt;/Route&gt; &lt;Route path='/home' component=&#123;Home&#125;&gt;&lt;/Route&gt; &lt;/div&gt; &lt;/HashRouter&gt; //或则使用BrowserRouter这样 &lt;Router&gt; &lt;div&gt; &lt;Route exact path='/' component=&#123;Login&#125;&gt;&lt;/Route&gt; &lt;Route path='/home' component=&#123;Home&#125;&gt;&lt;/Route&gt; &lt;/div&gt; &lt;/Router&gt; 在这里我们要说说HashRouter和BrowserRouter的区别 BrowserRouter使用HTML5历史记录API（pushState，replaceState和popstate事件）来保持您的UI与URL同步 HashRouter使用URL的哈希部分（即window.location.hash）来保持您的UI与URL同步，使得路径上会出现 # 键 (二) RouteRoute 就像原材料，控制着我们应该对应显示的内容，也是最重要的路由组件Route常用的属性，path、exact、component path：对应的路径 exact：仅当路径与location.pathname完全匹配时才匹配，当匹配到路劲后就不会再往下匹配 component：对应要显示的组件app.js12345678import &#123;BrowserRouter as Router, HashRouter, Route&#125; from \"react-router-dom\"; &lt;HashRouter&gt; &lt;div&gt; /*一般这里都要加个exact，不然切换路径后，两个路径对应的组件都会被显示出来*/ &lt;Route exact path='/' component=&#123;Login&#125;&gt;&lt;/Route&gt; &lt;Route path='/home' component=&#123;Home&#125;&gt;&lt;/Route&gt; &lt;/div&gt; &lt;/HashRouter&gt; (三) Link与NavLink&emsp;Link与NavLink都是控制路由跳转的，当然NavLink所具有的功能比Link更多，所以，使用的时候视情况而定。控制路由跳转这只是其中的一种方法，我们也可以使用react-router里面的js方法实现跳转12 先暂时写在这儿，等有时间再接着完善","categories":[{"name":"前端","slug":"前端","permalink":"http://q1019736727.github.io/categories/前端/"}],"tags":[{"name":"React","slug":"React","permalink":"http://q1019736727.github.io/tags/React/"},{"name":"react-router","slug":"react-router","permalink":"http://q1019736727.github.io/tags/react-router/"},{"name":"react-router-dom","slug":"react-router-dom","permalink":"http://q1019736727.github.io/tags/react-router-dom/"}]},{"title":"谈谈vuex","slug":"vuex","date":"2019-03-11T07:30:27.000Z","updated":"2019-04-08T14:10:16.000Z","comments":true,"path":"2019/03/11/vuex/","link":"","permalink":"http://q1019736727.github.io/2019/03/11/vuex/","excerpt":"简介&emsp;Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。&emsp;Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新&emsp;我们不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。","text":"简介&emsp;Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。&emsp;Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新&emsp;我们不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。 安装&emsp;vuex的安装12345//npm 方式引入npm install vuex --save//yarn 方式引入yarn add vuex vuex 基本概念vuex最主要的几个核心概念就是State,Getter,Mutations,Actions (一) Statestate就是Vuex中的公共的状态, 可以将state看作是所有组件的data, 用于保存所有组件的公共数据，这里面的数据是响应式的，当很多地方引用了同state数据源并且未对数据进行深拷贝，那么当一个地方改变该数据，所有引用的地方数据都会发生变化。 12345678910111213//定义import Vuex from 'vuex'import Vue from 'vue'Vue.use(Vuex)const store = new Vuex.Store(&#123; state:&#123; todoList:[1,2,3] &#125;&#125;)//组件获取this.$store.state.todoList (二) GetterGetter是对state里面的数据进行预加工处理的函数方法，当我们需要对原始数据进行一个处理时，我们就需要用到getter，1234567891011121314const store = new Vuex.Store(&#123; state: &#123; todoList: [ &#123; time: 1, text: 'do some'&#125;, &#123; time: 2, text: 'do some' &#125; ] &#125;, getters: &#123; //这里我们返回数据的长度 dealTodo: state =&gt; &#123; return state.todoList.length &#125; &#125;&#125;) Getter 会暴露为 store.getters 对象，我们可以以属性的形式访问这些值：12//使用this.$store.getters.dealTodo mapGetters 辅助函数当getters里面对象过多时，我们可以以ES6的语法形式解析里面的对象，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性computed： 123456789101112import &#123; mapGetters &#125; from 'vuex'export default &#123; computed: &#123; // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ 'getters1', 'getters2', 'getters3', ]) &#125;&#125; 当然我们也可以使用对象的形式放入123mapGetters(&#123; dataCount: 'getters1'&#125;) (三) MutationsMutations是更改 Vuex 的 store 中的状态的唯一方法，且不能用于处理异步事件,其中第一个参数是state, 第二参数是payload, 也就是传入数据123456789101112//实例const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state,payload) &#123; // 变更状态 state.count += payload.amount &#125; &#125;&#125;) 此时我们不能直接调用store里面的mutations实例方法，而是要通过commit方式对应的type来触发该方法12345678910//使用 //方式1this.$store.commit('increment',&#123;amount:100&#125;)//方式2 直接使用包含 type 属性的对象this.$store.commit(&#123; type: 'increment', amount: 10&#125;) Mutation 必须是同步函数，再次强调一下，所以存在异步操作的函数最好不要使用mutation里面的方法 mapMutations辅助函数mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）123456789101112131415161718import &#123; mapMutations &#125; from 'vuex'export default &#123; methods: &#123; //方式1 ...mapMutations([ 'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')` // `mapMutations` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)` ]), //方式2 ...mapMutations(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')` &#125;) &#125;&#125; (四) Actionaction 类似于 mutation，不同在于： action 提交的是 mutation，而不是直接变更状态。 action 可以包含任意异步操作。 actions中的回调函数的第一个参数是context, 是一个与store实例具有相同属性和方法的对象12345678910111213141516171819202122const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; //写法1 increment (context) &#123; context.commit('increment') &#125;, //写法2 我们也可以使用ES6语法 increment (&#123;state,commit&#125;) &#123; commit('increment') &#125; &#125;&#125;) action的触发,当然action也和mutation的触发方式差不多，也同样支持包含 type 属性的对象方式分发，下面我们就简单写一种,当然关键字不一样，这个触发关键字是dispatch1this.$store.dispatch('increment',data) 在上面我们也说到action可以进行异步操作，那么我们就可以以promise为例简单实现一下1234567891011const store = &#123; //... actions:&#123; increment(&#123;commit&#125;,data)&#123; return new Promise((resolve)=&gt;&#123; commit('increment',data) resolve() &#125;) &#125; &#125;&#125; mapActions辅助函数mapActions 辅助函数将组件中的 methods 映射为 store.dispatch 调用（需要在根节点注入 store）12345678910111213141516171819import &#123; mapActions &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapActions([ // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')` 'increment', // `mapActions` 也支持载荷： // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)` 'incrementBy' ]), ...mapActions(&#123; // 将 `this.add()` 映射为 `this.$store.dispatch('increment')` add: 'increment' &#125;) &#125;&#125; vuex项目结构拆分当项目store文件很大的时候，我们就不得不拆分项目的目录结构，大体上我们必须准守以下规则 应用层级的状态应该集中到单个 store 对象中。 提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。 异步逻辑都应该封装到 action 里面。 只要遵循上面的规则，代码可以任意组织，下面是我经常性使用的组合形式1234567891011└── store ├── index.js ├── Type.js ├── binding │ ├── actions.js │ ├── index.js │ └── mutations.js ├── house ├── actions.js ├── index.js └── mutations.js store的根目录index.js用于整合各个局部状态store，使用modules整合12345678910111213141516//文件 store/index.jsimport Vuex from 'vuex'import Vue from 'vue'import houseStore from './house'import bindingStore from './binding'Vue.use(Vuex)const store = new Vuex.Store(&#123; modules:&#123; house:houseStore, //house store binding:bindingStore //binding store &#125;&#125;)export default store Type.js主要用于存储事件type名123456//Type.js//例如...//操作1export const RRDUCELIST = 'RRDUCELIST'//操作2export const ADDLIST = 'ADDLIST' 局部store我就以binding为例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*----------------------------index.js-----------------------------*///index.jsimport &#123;RRDUCELIST&#125; from '@/store/Type.js'import mutations from './mutations'import actions from './actions'const index = &#123; state:&#123; tableDta:[ &#123;data:['数据1','数据2','数据3']&#125;, ] &#125;, mutations, actions,&#125;export default index/*----------------------------mutations.js-----------------------------*///mutationsimport &#123;RRDUCELIST,ADDLIST&#125; from '@/store/Type.js'const mutations = &#123; //删除数据 [RRDUCELIST](state, payload) &#123; state.tableDta.splice(0, 1) &#125;, //增加数据 [ADDLIST](state,payload)&#123; state.tableDta.push(payload) &#125;&#125;export default mutations/*----------------------------actions.js-----------------------------*///actionsimport &#123;RRDUCELIST,ADDLIST&#125; from '@/store/Type.js'const actions = &#123; reduceListAction(&#123;commit,state&#125;,index)&#123; return new Promise((resolve, reject) =&gt; &#123; commit(RRDUCELIST,index) resolve() &#125;) &#125;, addListAction(&#123;state,commit&#125;,data)&#123; commit(ADDLIST,data) &#125;&#125;export default actions","categories":[{"name":"前端","slug":"前端","permalink":"http://q1019736727.github.io/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://q1019736727.github.io/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"http://q1019736727.github.io/tags/vuex/"}]},{"title":"SCSS常用基础功能整理","slug":"scss","date":"2019-03-06T13:01:54.000Z","updated":"2019-04-08T14:10:16.000Z","comments":true,"path":"2019/03/06/scss/","link":"","permalink":"http://q1019736727.github.io/2019/03/06/scss/","excerpt":"","text":"&emsp;Sass 是一门高于 CSS 的元语言，它能用来清晰地、结构化地描述文件样式，有着比普通 CSS 更加强大的功能。&emsp;Sass 能够提供更简洁、更优雅的语法，同时提供多种功能来创建可维护和管理的样式表。其中Scss就是演化于Sass，Sass诞生于Ruby社区，只不过Sass写法更加的精简，Sass是有严格的缩进规范并且没有‘{}’和‘；’。而Scss则和css的规范是一致的。 mixin &emsp;可以设置的通用样式，避免繁琐的重复代码，让css看起来更具条理性 &emsp;关键字@mixin @include1234567891011121314//定义一个debug样式@mixin dbug &#123; border: 1px solid red;&#125;#container &#123; //使用关键字@include使用该样式 @include dbug; .box1 &#123; color: red; &#125; .box2 &#123; color: blue; &#125; &#125; &emsp;当然mixin里面也和js的函数一样，可以接受参数1234567891011121314@mixin dbug($color) &#123; //接受形参$color border: 1px solid $color;&#125;#container &#123; $R: #eee;//定义一个color值 @include dbug($R); &gt;.box1 &#123; color: red; &#125; &gt;.box2 &#123; color: blue; &#125; &#125; %placeholder&emsp;placeholder的用法和mixin的用法差不多一样,只是不能接受参数,使用时前面修饰符是@extend&emsp;关键字% @extend ，那么用%placeholder的方式上面可以写成12345678910111213//不能接受参数%dbug&#123; border: 1px solid red;&#125;#container &#123; @extend %dbug; &gt;.box1 &#123; color: red; &#125; &gt;.box2 &#123; color: blue; &#125;&#125; &amp;以及冒号:的运用&emsp;&amp;代表着当前选择器,:冒号相当于一个连接符12345678910111213141516.userCard&#123; width: 100px; //多类选择器 &amp;.active&#123; background: yellow; &#125; //详当于是 .userCard-name 的写法 &amp;-name&#123; color: black; // font-size font-weight font:&#123; size: 28px; weight: bold; &#125; &#125;&#125; 除法运算&emsp;以下三种情况 / (斜杠)将被视为除法运算符号： &emsp;1.如果值，或值的一部分，是变量或者函数的返回值&emsp;2.如果值被圆括号包裹&emsp;3.如果值是算数表达式的一部分1234567891011121314151617p &#123; font: 10px/8px; // 直接使用除法，不会触发运算 $width: 1000px; width: $width/2; // 使用变量,触发运算 width: round(1.5)/2; // 使用一个函数,触发运算 height: (500px/2); // 使用括号,触发运算 margin-left: 5px + 8px/2px; // 使用加号,触发运算&#125;编译为p &#123; font: 10px/8px; //直接使用 / (斜杠),并未被编译 width: 500px; height: 250px; margin-left: 9px; &#125; 媒体查询12345678910111213141516171819202122232425262728293031//手机宽度@mixin phone &#123; @media (max-width: 500px) &#123; @content; &#125;&#125;//ipad宽度@mixin ipad &#123; @media (min-width: 501px) and (max-width: 1024px) &#123; @content; &#125;&#125;//pc宽度@mixin pc &#123; @media (min-width: 1025px) &#123; @content; &#125;&#125;//使用#container&#123; @include phone &#123; background: red; &#125; @include ipad&#123; background: blue; &#125; @include pc&#123; background: green; &#125;&#125; @function的使用这个和js的写法都差不多,可以传入一个参数，并返回处理后的数据12345678@function px($value)&#123; @return $value/2 + px;&#125;#container&#123; width: px(200); height: px(200); background:#000;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://q1019736727.github.io/categories/前端/"}],"tags":[{"name":"scss","slug":"scss","permalink":"http://q1019736727.github.io/tags/scss/"}]},{"title":"写一个简单的事件订阅中心eventsHub","slug":"eventshub","date":"2019-03-06T01:51:50.000Z","updated":"2019-04-08T14:10:16.000Z","comments":true,"path":"2019/03/06/eventshub/","link":"","permalink":"http://q1019736727.github.io/2019/03/06/eventshub/","excerpt":"&emsp;在有些时候，当我们写了两个组件，当需要相互通信，该想想怎么使两个组件之间可以互相监听事件，并且能够传递obj，那下面我们用VanillaJS来实现一个简单的小demo吧。","text":"&emsp;在有些时候，当我们写了两个组件，当需要相互通信，该想想怎么使两个组件之间可以互相监听事件，并且能够传递obj，那下面我们用VanillaJS来实现一个简单的小demo吧。 首先创建一个事件对象 1const eventsHub = &#123;&#125; &emsp;那么接下来创建一个事件中心用来存储事件，创建的时候最好以obj的形式，不要以array形式创建。以obj方式我们能更快以订阅事件的name快速读取里面储存的fuction。 1234const eventsHub = &#123; //用于存储事件 events:&#123;&#125;&#125; 事件绑定 &emsp;事件绑定的时候，我们需要传入对应的事件名称key，以及callback函数，然后我们再拿这个key去事件中心去寻找是否存在该事件，存在该事件就继续网里面添加callback函数，不存在将该事件初始化一个空的Array，然后将传入的callback函数push进去 123456on:function (bindname,fn) &#123; if (this.events[bindname] === undefined)&#123; this.events[bindname] = [] &#125; this.events[bindname].push(fn) &#125; 事件执行 &emsp;查找该执行事件的key，获取Array里面的callback函数，全部执行 1234567emit:function (bindname,data) &#123; if (this.events[bindname]) &#123; this.events[bindname].map((fn)=&gt;&#123; fn.call(undefined,data) &#125;) &#125;&#125;, 使用 1234567891011121314151617181920212223242526272829const eventsHub = &#123; events:&#123;&#125;, //执行事件 emit:function (bindname,data) &#123; if (this.events[bindname]) &#123; this.events[bindname].map((fn)=&gt;&#123; fn.call(undefined,data) &#125;) &#125; &#125;, //绑定事件 on:function (bindname,fn) &#123; if (this.events[bindname] === undefined)&#123; this.events[bindname] = [] &#125; this.events[bindname].push(fn) &#125; &#125;export default eventsHub//订阅eventsHub.on('eventName',(res)=&gt;&#123; //... do something&#125;)//执行 eventsHub.emit('eventName',data)","categories":[{"name":"前端","slug":"前端","permalink":"http://q1019736727.github.io/categories/前端/"}],"tags":[{"name":"eventsHub","slug":"eventsHub","permalink":"http://q1019736727.github.io/tags/eventsHub/"}]},{"title":"vue仿写cnode社区","slug":"cnode","date":"2019-03-04T01:41:42.000Z","updated":"2023-10-11T02:16:44.126Z","comments":true,"path":"2019/03/04/cnode/","link":"","permalink":"http://q1019736727.github.io/2019/03/04/cnode/","excerpt":"&emsp;写的一个vue小项目,接口基于cnode社区开放接口,项目使用Vue2.0实现,写了一段时间了总结一下项目，该项目未适配手机屏幕。 源码地址 | 预览地址 项目主体结构 &emsp;因为项目较小,就没有使用vuex,网络方面使用axios。","text":"&emsp;写的一个vue小项目,接口基于cnode社区开放接口,项目使用Vue2.0实现,写了一段时间了总结一下项目，该项目未适配手机屏幕。 源码地址 | 预览地址 项目主体结构 &emsp;因为项目较小,就没有使用vuex,网络方面使用axios。 axios挂载 &emsp;一般当我们网络请求时，都需要一个网络框架，这里我选择axios。每当一个组件需要网络请求时，都需要引入axios模块，为了避免这种重复操作，可以把axios挂载到Vue的原型上 &emsp;入口文件main.js 12345import Axios from 'axios'import Vue from 'vue'/*这里可以随便命名,为了方便记住,我命名$http*/Vue.prototype.$http = Axios &emsp;需要使用的组件调用123456789this.$http.get('...',&#123; params: &#123; ...params &#125; &#125;).then((res) =&gt; &#123; // ... do something &#125;).catch(error =&gt;&#123; // ... do something &#125;) 路由配置 &emsp;总共5个组件模块，顶部导航栏、主页列表、详情即评论区域、个人详情、分页器 详情页的数据信息因为返回的html数据形式，这里引入了一个第三方mardown文本样式 1@import url('../assets/markdown.css');//引入markdown样式 &emsp;vue-router路由配置信息1234567891011121314151617181920212223242526272829Router(&#123; // 如果需要去掉路径上的#，model使用history模式 // mode:'history', routes: [ &#123; name:'root',//router-link跳转时需要使用 path:'/', components:&#123; main: Publish//这里和下面命名main是因为渲染的时候(router-view 时需要用) &#125; &#125;, &#123; name:'post-detail', path:'/topic/:id&amp;:name',//需要传递参数id和name,注意在 components:&#123; main: Postdetail, slider: Slider &#125; &#125;, &#123; name:'user-page', path:'/user/:username', components:&#123; main:Userinfo &#125; &#125;, ]&#125;) 分页器的实现 &emsp;在主页的底部，我们需要一个分页器。首先我们要理清需求，做一个最多显示5页的分页器，当大于5页的时候，前面显示省略号，页数也都加1，当页数小于5时，前面的省略号消失。 &emsp;大体效果如下 &emsp;首先我们构建一个分页容器,其中ismore用于判断是否显示前边的省略号，selectIndex用于判断当前选中页数 1234567&lt;div class=\"page-wrapper\"&gt; &lt;button @click=\"changeBtn\"&gt;首页&lt;/button&gt; &lt;button @click=\"changeBtn\"&gt;上一页&lt;/button&gt; &lt;button v-show=\"ismore\"&gt;......&lt;/button&gt; &lt;button @click=\"changeBtn(item)\" v-for=\"item in Pages\" :class=\"&#123;active: selectIndex === item&#125;\"&gt;&#123;&#123;item&#125;&#125;&lt;/button&gt; &lt;button @click=\"changeBtn\"&gt;下一页&lt;/button&gt;&lt;/div&gt; &emsp;初始数据值1234567data:function() &#123; return&#123; Pages:[1,2,3,4,5,'......'],//初始页数 selectIndex:1,//初始选中状态 ismore:false//是否显示前面的...... &#125;&#125; &emsp; 按钮点击逻辑处理1234567891011121314151617181920212223242526272829303132333435363738changeBtn(page)&#123; //过滤点击省略号事件 if (typeof page !== 'number') &#123; if (typeof page === 'string')&#123; return &#125; let str = page.currentTarget.innerText switch (str) &#123; case '首页': this.Pages = [1,2,3,4,5,'......']; this.changeBtn(1); break case '上一页': this.$jq('button.active').prev().click() break case '下一页': this.$jq('button.active').next().click() break &#125; return &#125; this.selectIndex = page; if(page&gt;4)&#123;//判断是否显示省略号 this.ismore = true; &#125;else&#123; this.ismore = false; &#125; //页码状态处理 if(page == this.Pages[4] )&#123; this.Pages.shift(); this.Pages.splice(4,0,this.Pages[3]+1); &#125;else if(page == this.Pages[0] &amp;&amp; page !=1)&#123; this.Pages.unshift(this.Pages[0]-1); this.Pages.splice(5,1); &#125; //通知主页按钮已经点击，实时更新数据 this.$emit('changePage',page) &#125; 总结 &emsp;总的说来，这是一个非常适合练手的项目，逻辑简单明了，页面逻辑也不是很复杂，可能其中还有些没讲到，不过可以下载源码在细致看一下，上面这些是我大致认为该项目还比较重要的内容，以此做个记录","categories":[{"name":"前端","slug":"前端","permalink":"http://q1019736727.github.io/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://q1019736727.github.io/tags/vue/"}]},{"title":"hello world","slug":"hello-world","date":"2019-02-27T03:36:51.000Z","updated":"2019-04-08T14:10:16.000Z","comments":true,"path":"2019/02/27/hello-world/","link":"","permalink":"http://q1019736727.github.io/2019/02/27/hello-world/","excerpt":"","text":"","categories":[],"tags":[]}]}